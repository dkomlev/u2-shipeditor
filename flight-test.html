<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>U2 FlightTest</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #000;
      color: #e0e8f0;
      overflow: hidden;
    }
    #gameCanvas {
      display: block;
      background: radial-gradient(circle at 30% 40%, rgba(10, 20, 40, 0.4), #000);
    }
    
    /* HUD Panels */
    .hud-panel {
      position: fixed;
      padding: 12px 16px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 13px;
      line-height: 1.5;
      font-family: 'Courier New', monospace;
    }
    
    #hudTopLeft {
    #zoomControls {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-family: 'Courier New', monospace;
      z-index: 900;
    }

    #zoomControls button {
      width: 36px;
      height: 36px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.05);
      color: #e0e8f0;
      font-size: 18px;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease;
    }

    #zoomControls button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.6);
    }

    #zoomValue {
      min-width: 72px;
      text-align: center;
      font-size: 14px;
      letter-spacing: 0.05em;
    }

      top: 16px;
      left: 16px;
      min-width: 280px;
    }
    
    #hudTopRight {
      top: 16px;
      right: 16px;
      text-align: right;
    }
    
    #hudBottomLeft {
      bottom: 16px;
      left: 16px;
    }
    
    #hudBottomRight {
      bottom: 16px;
      right: 16px;
      text-align: right;
    }
    
    .hud-panel strong {
      color: #8ef2ff;
    }
    
    .hud-title {
      font-size: 15px;
      font-weight: bold;
      margin-bottom: 8px;
      color: #fff;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 4px;
    }
    
    .hud-value {
      display: inline-block;
      min-width: 80px;
    }
    
    .mode-coupled { color: #4ade80; }
    .mode-decoupled { color: #fbbf24; }
    .mode-brake { color: #ef4444; }
    
    .sr-active { color: #a78bfa; }
    .collision-warning { color: #f87171; animation: blink 0.5s infinite; }
    
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }
    
    /* Loading screen */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      z-index: 1000;
    }
    
    #loading.hidden {
      display: none;
    }
    
    .spinner {
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top: 3px solid #8ef2ff;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-right: 16px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
  <script src="js/lib/build-info.js"></script>
  <script>
    (function () {
      const info = (typeof window !== "undefined" && window.U2BuildInfo) || null;
      if (info && info.label) {
        document.title = `U2 FlightTest ${info.label}`;
      }
    })();
  </script>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <span id="loadingStatus">Loading FlightTest...</span>
  </div>
  <script>
    (function () {
      const info = (typeof window !== "undefined" && window.U2BuildInfo) || {};
      const buildId = info.buildId || (typeof info.build === "number" ? info.build.toString().padStart(3, "0") : "000");
      const version = info.version || "0.0.0";
      const label = info.label || `v${version} build ${buildId}`;
      const el = document.getElementById("loadingStatus");
      if (el) {
        el.textContent = `Loading FlightTest ${label}...`;
      }
    })();
  </script>

  <canvas id="gameCanvas"></canvas>

  <div id="zoomControls" aria-label="Zoom controls">
    <button type="button" data-zoom="out" aria-label="Zoom out">-</button>
    <span id="zoomValue">100%</span>
    <button type="button" data-zoom="in" aria-label="Zoom in">=</button>
  </div>

  <!-- HUD Panels -->
  <div id="hudTopLeft" class="hud-panel">
    <div class="hud-title">SHIP STATUS</div>
    <div id="shipStatus"></div>
  </div>

  <div id="hudTopRight" class="hud-panel">
    <div class="hud-title">FLIGHT MODE</div>
    <div id="flightMode"></div>
  </div>

  <div id="hudBottomLeft" class="hud-panel">
    <div class="hud-title">PHYSICS</div>
    <div id="physicsInfo"></div>
  </div>

  <div id="hudBottomRight" class="hud-panel">
    <div class="hud-title">ENVIRONMENT</div>
    <div id="envInfo"></div>
  </div>

  <!-- Scripts -->
  <script src="js/lib/app-config-loader.js"></script>
  <script src="js/lib/ship-adapter.js"></script>
  <script src="js/lib/resources.js"></script>
  <script src="js/sim/relativity.js"></script>
  <script src="js/sim/core.js"></script>
  <script src="js/sim/input.js"></script>
  <script src="js/sim/coupled-controller.js"></script>
  <script src="js/sim/pilot-assist.js"></script>
  <script src="js/sim/asteroids.js"></script>
  <script src="js/sim/collision.js"></script>
  <script>
    (async function () {
      const buildInfo = (typeof window !== "undefined" && window.U2BuildInfo) || {
        version: "0.0.0",
        build: 0,
        buildId: "000",
        label: "v0.0.0 build 000"
      };
      const APP_VERSION = buildInfo.version || "0.0.0";
      const BUILD_NUMBER = buildInfo.buildId || (typeof buildInfo.build === "number" ? buildInfo.build.toString().padStart(3, "0") : "000");
      const BUILD_LABEL = buildInfo.label || `v${APP_VERSION} build ${BUILD_NUMBER}`;
      try {
        console.log(`FlightTest ${BUILD_LABEL}: Starting initialization...`);
      
        const appConfigLoader = window.U2AppConfigLoader;
        const resources = window.U2Resources;
        const adapter = window.U2ShipAdapter;
        const core = window.U2SimCore;
        const inputLib = window.U2InputController;
        const assistLib = window.U2PilotAssist;
        const asteroidLib = window.U2AsteroidGenerator;
        const collisionLib = window.U2CollisionDetector;

      console.log("Checking dependencies:", {
        appConfigLoader: !!appConfigLoader,
        resources: !!resources,
        adapter: !!adapter,
        core: !!core,
        inputLib: !!inputLib,
        assistLib: !!assistLib,
        asteroidLib: !!asteroidLib,
        collisionLib: !!collisionLib
      });

      if (!appConfigLoader || !resources || !adapter || !core || !inputLib || !assistLib || !asteroidLib || !collisionLib) {
        console.error("Missing dependencies");
        document.getElementById("loading").innerHTML = `
          <div class="spinner"></div>
          <span style="color: #f87171;">Failed to load modules. Check console (F12).</span>
        `;
        return;
      }

      // Load AppConfig
      console.log("Loading AppConfig...");
      const appConfig = await appConfigLoader.loadAppConfig();
      console.log("AppConfig loaded:", appConfig);
      const hasInlineShip = Boolean(appConfig.inline_ship);
      const pixelsPerMeter = appConfig.render?.pixels_per_meter ?? 0.4;
      const zoom = createZoomState(appConfig.render, pixelsPerMeter);
      const initialZoomPercent = Number(appConfig.render?.initial_zoom_percent) || 1000;
      let currentScale = zoom.value;
      const zoomValueEl = document.getElementById("zoomValue");
      const zoomOutBtn = document.querySelector('[data-zoom="out"]');
      const zoomInBtn = document.querySelector('[data-zoom="in"]');
      bindZoomButtons(zoomOutBtn, zoomInBtn);
      updateZoomDisplay();

      // Load ShipConfig
      let manifest = [];
      if (!hasInlineShip) {
        console.log("Loading manifest...");
        try {
          await resources.loadManifest();
          console.log("Manifest loaded successfully");
          manifest = resources.getManifestSync() || [];
          console.log("Manifest entries:", manifest.length);
        } catch (error) {
          console.error("Failed to load manifest:", error);
          document.getElementById("loading").innerHTML = `
            <div class="spinner"></div>
            <span style="color: #f87171;">Failed to load manifest: ${error.message}</span>
          `;
          return;
        }

        if (!manifest.length) {
          console.error("Manifest is empty");
          document.getElementById("loading").innerHTML = `
            <div class="spinner"></div>
            <span style="color: #f87171;">No ships found in manifest</span>
          `;
          return;
        }
      } else {
        console.log("Inline ShipConfig payload detected; manifest load skipped.");
      }

      // Load ship from AppConfig path, inline payload, or random
      let shipPath = hasInlineShip ? null : appConfig.paths?.ship_config_path;
      let shipJson = null;

      if (!hasInlineShip) {
        if (shipPath) {
          const pathExists = manifest.some((entry) => entry.path === shipPath);
          if (!pathExists) {
            console.warn(`Ship path from AppConfig not found: ${shipPath}. Using random ship.`);
            shipPath = null;
          }
        }

        if (!shipPath) {
          const randomIndex = Math.floor(Math.random() * manifest.length);
          shipPath = manifest[randomIndex].path;
          console.log(`Selected random ship: ${shipPath}`);
        }

        console.log("Loading ship:", shipPath);
        shipJson = await resources.getShipConfig(shipPath);
        console.log("Ship JSON loaded:", shipJson);
      } else {
        shipJson = appConfig.inline_ship;
        shipPath =
          appConfig.selected_ship?.path ||
          appConfig.selected_ship?.id ||
          appConfig.selected_ship?.name ||
          "inline";
        console.log("Using inline ShipConfig from launcher payload.");
      }
      
      const summary = adapter.parseShipConfig(shipJson, shipPath);
      console.log("Ship summary:", summary.name);
      const shipGeometry = normalizeGeometry(shipJson.geometry || summary.geometry);
      let shipSpriteImage = null;
      try {
        shipSpriteImage = await loadShipSprite(summary.sprite);
      } catch (error) {
        console.warn("Failed to load ship sprite, falling back to marker.", error);
      }
      const shipVisual = {
        sprite: shipSpriteImage,
        geometry: shipGeometry,
        hullRadius: shipGeometry.hull_radius_m ?? Math.max(shipGeometry.length_m, shipGeometry.width_m) * 0.5
      };

      // Setup canvas
      console.log("Setting up canvas...");
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      canvas.width = appConfig.render.canvas?.width || window.innerWidth;
      canvas.height = appConfig.render.canvas?.height || window.innerHeight;
      console.log("Canvas size:", canvas.width, "x", canvas.height);
      applyInitialZoom(canvas, shipGeometry, initialZoomPercent);

      // Create simulation state
      console.log("Creating simulation state...");
      const state = core.createState({
        mass_t: summary.mass_t ?? shipJson.mass?.dry_t ?? shipJson.mass_t ?? 1,
        propulsion: shipJson.propulsion,
        geometry: shipGeometry,
        performance: shipJson.performance,
        inertia_opt: shipJson.inertia_opt
      });
      console.log("State created:", state);

      const autopilotStart = appConfig.autopilot?.enabled_on_start ?? true;
      const coupledStart = appConfig.autopilot?.coupled_on_start ?? true;
      const input = inputLib.createInputController(appConfig.input, {
        autopilotEnabled: autopilotStart,
        coupled: coupledStart
      });
      const assist = assistLib.createPilotAssist(summary);
      console.log("Input and assist controllers created");

      // Generate asteroids
      console.log("Generating asteroids...");
      const asteroids = asteroidLib.generateAsteroids(appConfig);
      console.log(`Asteroids generated: ${asteroids.length}`);

      // Collision state
      let collisionMode = appConfig.collision.mode; // "AABB" or "Alpha"
      let collisionOverlay = appConfig.collision.overlay; // boolean

      // Note: Input controller manages its own coupled/autopilot state internally
      console.log(`Input controller configured: coupled=${coupledStart}, autopilot=${autopilotStart}`);

      // Additional key bindings for FlightTest
      document.addEventListener("keydown", (e) => {
        if (e.key === "-" || e.key === "_") {
          e.preventDefault();
          e.stopPropagation();
          adjustScale("out");
          return;
        }
        if (e.key === "=" || e.key === "+") {
          e.preventDefault();
          e.stopPropagation();
          adjustScale("in");
          return;
        }
        if (e.key === "F2") {
          e.preventDefault();
          collisionMode = collisionMode === "AABB" ? "Alpha" : "AABB";
          console.log(`Collision mode: ${collisionMode}`);
        }
        if (e.key === "F3") {
          e.preventDefault();
          collisionOverlay = !collisionOverlay;
          console.log(`Collision overlay: ${collisionOverlay}`);
        }
      });

      // Event listeners
      document.addEventListener("keydown", input.handleKeyDown);
      document.addEventListener("keyup", input.handleKeyUp);
      window.addEventListener("blur", () => input.handlePointerEnd());

      // Hide loading screen
      console.log("Initialization complete! Starting main loop...");
      document.getElementById("loading").classList.add("hidden");

      // Main loop
      let lastTime = performance.now();
      function loop(now) {
        try {
          const dt = Math.min((now - lastTime) / 1000, appConfig.physics.dt_sec * 2);
          lastTime = now;

          const normalizedInput = input.update();
          const assistResult = assist.update(state, normalizedInput, {
            dt_sec: appConfig.physics.dt_sec,
            c_mps: appConfig.physics.c_mps,
            inertia: 1
          });

          const nextState = core.step(state, assistResult.command, {
            dt_sec: appConfig.physics.dt_sec,
            c_mps: appConfig.physics.c_mps,
            inertia: 1
          });

          // Update state
          Object.assign(state, nextState);

          // Update asteroids
          asteroidLib.updateAsteroids(asteroids, appConfig.physics.dt_sec);
          asteroidLib.wrapAsteroids(asteroids, appConfig.world.bounds);

          // Check collisions
          const shipCollider = buildShipCollider(state, shipVisual);
          const collisions = collisionLib.checkShipCollisions(
            shipCollider,
            asteroids,
            collisionMode
          );

          // Render
          draw(ctx, canvas, state, asteroids, collisions, appConfig, shipVisual, currentScale);
          if (collisionOverlay) {
            collisionLib.renderCollisionOverlay(
              ctx,
              shipCollider,
              asteroids,
              collisions,
              state.camera || state,
              currentScale
            );
          }
          updateHUD(state, assistResult, normalizedInput, summary, appConfig, asteroids, collisions, zoom, currentScale);

          requestAnimationFrame(loop);
        } catch (error) {
          console.error("Error in main loop:", error);
          document.getElementById("loading").classList.remove("hidden");
          document.getElementById("loading").innerHTML = `
            <div style="color: #f87171; max-width: 600px; text-align: left;">
              <h2>Runtime Error</h2>
              <pre style="background: rgba(0,0,0,0.5); padding: 16px; border-radius: 8px; overflow: auto;">${error.stack || error.message}</pre>
              <p>Check console (F12) for details.</p>
            </div>
          `;
        }
      }
      requestAnimationFrame(loop);

      function draw(ctx, canvas, state, asteroids, collisions, config, shipVisual, scale) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Render grid (from sim-demo.html)
        if (config.render.grid?.enabled) {
          drawGrid(ctx, canvas, state, config.render.grid, scale);
        }

        // Render asteroids first (background)
        asteroidLib.renderAsteroids(ctx, asteroids, state.camera || state, scale);

        drawShipSprite(ctx, canvas, state, collisions.length > 0, shipVisual, scale);

      }

      function bindZoomButtons(outBtn, inBtn) {
        if (outBtn) {
          outBtn.addEventListener("click", () => adjustScale("out"));
        }
        if (inBtn) {
          inBtn.addEventListener("click", () => adjustScale("in"));
        }
      }

      function updateZoomDisplay() {
        if (!zoomValueEl) {
          return;
        }
        const percent = Math.round((zoom.value / zoom.default) * 100);
        zoomValueEl.textContent = `${percent}%`;
      }

      function setScale(nextScale) {
        const clamped = clampNumber(nextScale, zoom.min, zoom.max, zoom.value);
        zoom.value = clamped;
        currentScale = clamped;
        updateZoomDisplay();
      }

      function adjustScale(direction) {
        const factor = direction === "in" ? zoom.factor : 1 / zoom.factor;
        setScale(zoom.value * factor);
      }

      function applyInitialZoom(canvas, geometry, percentOverride) {
        if (Number.isFinite(percentOverride) && percentOverride > 0) {
          setScale(zoom.default * (percentOverride / 100));
          return;
        }
        const autoScale = computeAutoScale(canvas, geometry, zoom.default);
        setScale(autoScale);
      }

      function computeAutoScale(canvas, geometry, fallbackScale) {
        if (!canvas || !geometry) {
          return fallbackScale;
        }
        const paddingRatio = 0.6;
        const length = geometry.length_m ?? 40;
        const width = geometry.width_m ?? 20;
        const scaleByLength = (canvas.width * paddingRatio) / length;
        const scaleByWidth = (canvas.height * paddingRatio) / width;
        const candidate = Math.min(scaleByLength, scaleByWidth);
        if (!Number.isFinite(candidate) || candidate <= 0) {
          return fallbackScale;
        }
        return candidate;
      }

      function createZoomState(renderConfig = {}, defaultScale = 0.4) {
        const min = clampNumber(renderConfig?.pixels_per_meter_min, 0.02, 10, 0.05);
        const max = clampNumber(renderConfig?.pixels_per_meter_max, min + 0.01, 20, 2.5);
        const factor = clampNumber(renderConfig?.zoom_factor, 1.05, 2.5, 1.2);
        return {
          default: defaultScale,
          value: defaultScale,
          min: Math.min(min, defaultScale * 0.1),
          max: Math.max(max, defaultScale * 50),
          factor
        };
      }

      function drawGrid(ctx, canvas, state, gridConfig, scale = 0.4) {
        const cameraPos = state.camera?.position ?? state.position;
        const spacingWorld = gridConfig.cell || 250; // meters
        const spacingPx = spacingWorld * scale;
        
        const halfWidthWorld = canvas.width / 2 / scale;
        const halfHeightWorld = canvas.height / 2 / scale;
        const minX = cameraPos.x - halfWidthWorld - spacingWorld;
        const maxX = cameraPos.x + halfWidthWorld + spacingWorld;
        const minY = cameraPos.y - halfHeightWorld - spacingWorld;
        const maxY = cameraPos.y + halfHeightWorld + spacingWorld;
        
        const firstX = Math.floor(minX / spacingWorld) * spacingWorld;
        const firstY = Math.floor(minY / spacingWorld) * spacingWorld;
        
        const halfWidthPx = canvas.width / 2;
        const halfHeightPx = canvas.height / 2;

        ctx.save();
        ctx.translate(halfWidthPx, halfHeightPx);
        ctx.strokeStyle = `rgba(255, 255, 255, ${gridConfig.alpha || 0.15})`;
        ctx.lineWidth = 1;

        // Vertical lines
        for (let x = firstX; x <= maxX; x += spacingWorld) {
          const screenX = (x - cameraPos.x) * scale;
          ctx.beginPath();
          ctx.moveTo(screenX, -halfHeightPx - spacingPx);
          ctx.lineTo(screenX, halfHeightPx + spacingPx);
          ctx.stroke();
        }
        
        // Horizontal lines
        for (let y = firstY; y <= maxY; y += spacingWorld) {
          const screenY = -(y - cameraPos.y) * scale;
          ctx.beginPath();
          ctx.moveTo(-halfWidthPx - spacingPx, screenY);
          ctx.lineTo(halfWidthPx + spacingPx, screenY);
          ctx.stroke();
        }

        // Origin crosshair (brighter)
        ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
        ctx.lineWidth = 2;
        const originX = (0 - cameraPos.x) * scale;
        const originY = -(0 - cameraPos.y) * scale;
        
        ctx.beginPath();
        ctx.moveTo(originX - 12, originY);
        ctx.lineTo(originX + 12, originY);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(originX, originY - 12);
        ctx.lineTo(originX, originY + 12);
        ctx.stroke();

        ctx.restore();
      }

      function drawShipSprite(ctx, canvas, state, hasCollisions, shipVisual, scale) {
        const sprite = shipVisual.sprite;
        const geometry = shipVisual.geometry;
        const cameraPos = state.camera?.position ?? state.position;
        const screenX = (state.position.x - cameraPos.x) * scale;
        const screenY = -(state.position.y - cameraPos.y) * scale;
        const lengthPx = (geometry.length_m ?? 40) * scale;
        const widthPx = (geometry.width_m ?? 20) * scale;

        ctx.save();
        ctx.translate(canvas.width / 2 + screenX, canvas.height / 2 + screenY);
        ctx.rotate(-state.orientation);

        if (sprite) {
          const previousFilter = ctx.filter;
          const previousAlpha = ctx.globalAlpha;
          if (hasCollisions) {
            ctx.filter = "drop-shadow(0 0 12px rgba(248,113,113,0.85))";
            ctx.globalAlpha = 0.9;
          }
          ctx.drawImage(sprite, -lengthPx / 2, -widthPx / 2, lengthPx, widthPx);
          ctx.filter = previousFilter;
          ctx.globalAlpha = previousAlpha;
        } else {
          const nose = lengthPx / 2;
          const tail = -lengthPx / 2;
          const halfSpan = widthPx / 2;
          ctx.fillStyle = hasCollisions ? "#f87171" : "#7af";
          ctx.beginPath();
          ctx.moveTo(nose, 0);
          ctx.lineTo(tail, halfSpan);
          ctx.lineTo(tail, -halfSpan);
          ctx.closePath();
          ctx.fill();
        }

        ctx.restore();
      }

      function buildShipCollider(state, shipVisual) {
        const geometry = shipVisual.geometry;
        const padding = Math.max(shipVisual.hullRadius * 0.1, 2);
        const halfLength = (geometry.length_m ?? 40) / 2 + padding;
        const halfWidth = (geometry.width_m ?? 20) / 2 + padding;
        return {
          position: { x: state.position.x, y: state.position.y },
          radius: shipVisual.hullRadius || Math.max(halfLength, halfWidth),
          bounds: {
            minX: state.position.x - halfLength,
            maxX: state.position.x + halfLength,
            minY: state.position.y - halfWidth,
            maxY: state.position.y + halfWidth
          }
        };
      }

      function normalizeGeometry(raw = {}) {
        const length = clampNumber(raw.length_m, 5, 5_000, 40);
        const width = clampNumber(raw.width_m ?? length * 0.4, 5, 3_000, length * 0.4);
        const height = clampNumber(raw.height_m ?? width * 0.35, 1, 2_000, width * 0.35);
        const hullRadius = clampNumber(raw.hull_radius_m ?? Math.max(length, width) * 0.5, 5, 5_000, Math.max(length, width) * 0.5);
        return {
          length_m: length,
          width_m: width,
          height_m: height,
          hull_radius_m: hullRadius
        };
      }

      function clampNumber(value, min, max, fallback = min) {
        const numeric = typeof value === "number" && !Number.isNaN(value) ? value : fallback;
        return Math.min(Math.max(numeric, min), max);
      }

      function loadShipSprite(spriteMeta) {
        if (!spriteMeta?.value) {
          return Promise.resolve(null);
        }
        return new Promise((resolve, reject) => {
          const image = new Image();
          image.crossOrigin = "anonymous";
          image.onload = () => resolve(image);
          image.onerror = reject;
          image.src = spriteMeta.kind === "path" ? encodeURI(spriteMeta.value) : spriteMeta.value;
        });
      }

      function updateHUD(state, assistResult, input, summary, config, asteroids, collisions, zoomState, scale) {
        const speed = Math.hypot(state.velocity.x, state.velocity.y);
        const telemetry = assistResult.telemetry || {};
        
        // Ship Status
        document.getElementById("shipStatus").innerHTML = `
          <strong>${summary.name}</strong><br>
          Speed: <span class="hud-value">${speed.toFixed(1)} m/s</span><br>
          Position: ${state.position.x.toFixed(0)}, ${state.position.y.toFixed(0)}<br>
          Orientation: ${(state.orientation * 57.3).toFixed(1)}°
        `;
        
        // Flight Mode
        const modeClass = assistResult.mode === "Coupled" ? "mode-coupled" :
                         assistResult.mode === "Brake" ? "mode-brake" : "mode-decoupled";
        document.getElementById("flightMode").innerHTML = `
          <span class="${modeClass}"><strong>${assistResult.mode || "Decoupled"}</strong></span><br>
          Autopilot: ${assistResult.autopilot ? "ON" : "OFF"}<br>
          Boost: ${input.boost ? "ON" : "OFF"}
        `;
        
        // Physics
        const gamma = telemetry.gamma || 1;
        const srClass = telemetry.sr_active ? "sr-active" : "";
        document.getElementById("physicsInfo").innerHTML = `
          γ (Gamma): <span class="${srClass}">${gamma.toFixed(4)}</span><br>
          v/c: ${(telemetry.v_over_c || 0).toFixed(5)}<br>
          c: ${(config.physics.c_mps / 1000).toFixed(0)} km/s<br>
          dt: ${(config.physics.dt_sec * 1000).toFixed(1)} ms
        `;
        
        // Environment
        const collisionClass = collisions.length > 0 ? "collision-warning" : "";
        const zoomPercent = Math.round((scale / zoomState.default) * 100);
        document.getElementById("envInfo").innerHTML = `
          Asteroids: ${asteroids.length} / ${config.asteroids.count}<br>
          Collisions: <span class="${collisionClass}">${collisionMode}${collisions.length > 0 ? ` (${collisions.length})` : ''}</span><br>
          Overlay: ${collisionOverlay ? "ON (F3)" : "OFF (F3)"}<br>
          World: ${(config.world.bounds.width / 1000).toFixed(0)} × ${(config.world.bounds.height / 1000).toFixed(0)} km<br>
          Zoom: ${zoomPercent}% (-/=)<br>
          <span style="opacity: 0.6; font-size: 11px;">${BUILD_LABEL}</span>
        `;
      }
      
      } catch (error) {
        console.error("Initialization error:", error);
        document.getElementById("loading").innerHTML = `
          <div style="color: #f87171; max-width: 600px; text-align: left;">
            <h2>Initialization Error</h2>
            <pre style="background: rgba(0,0,0,0.5); padding: 16px; border-radius: 8px; overflow: auto; font-size: 12px;">${error.stack || error.message}</pre>
            <p>Check console (F12) for details.</p>
          </div>
        `;
      }
    })();
  </script>
</body>
</html>
